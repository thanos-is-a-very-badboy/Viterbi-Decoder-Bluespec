//
// Generated by Bluespec Compiler, version 2021.12.1 (build fd501401)
//
// On Wed Nov  5 19:27:41 IST 2025
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkViterbiTestbench(CLK,
			  RST_N);
  input  CLK;
  input  RST_N;

  // register emission_idx_tb
  reg [31 : 0] emission_idx_tb;
  wire [31 : 0] emission_idx_tb_D_IN;
  wire emission_idx_tb_EN;

  // register outcome_idx_tb
  reg [31 : 0] outcome_idx_tb;
  wire [31 : 0] outcome_idx_tb_D_IN;
  wire outcome_idx_tb_EN;

  // register read_emission_tb
  reg read_emission_tb;
  wire read_emission_tb_D_IN, read_emission_tb_EN;

  // register read_outcome_tb
  reg read_outcome_tb;
  wire read_outcome_tb_D_IN, read_outcome_tb_EN;

  // register read_transition_tb
  reg read_transition_tb;
  wire read_transition_tb_D_IN, read_transition_tb_EN;

  // register transition_idx_tb
  reg [31 : 0] transition_idx_tb;
  wire [31 : 0] transition_idx_tb_D_IN;
  wire transition_idx_tb_EN;

  // ports of submodule inputs
  wire [31 : 0] inputs_ADDR_1,
		inputs_ADDR_2,
		inputs_ADDR_3,
		inputs_ADDR_4,
		inputs_ADDR_5,
		inputs_ADDR_IN,
		inputs_D_IN,
		inputs_D_OUT_1;
  wire inputs_WE;

  // ports of submodule n_and_m
  wire [31 : 0] n_and_m_ADDR_1,
		n_and_m_ADDR_2,
		n_and_m_ADDR_3,
		n_and_m_ADDR_4,
		n_and_m_ADDR_5,
		n_and_m_ADDR_IN,
		n_and_m_D_IN,
		n_and_m_D_OUT_1,
		n_and_m_D_OUT_2;
  wire n_and_m_WE;

  // ports of submodule p_emission
  wire [31 : 0] p_emission_ADDR_1,
		p_emission_ADDR_2,
		p_emission_ADDR_3,
		p_emission_ADDR_4,
		p_emission_ADDR_5,
		p_emission_ADDR_IN,
		p_emission_D_IN,
		p_emission_D_OUT_1;
  wire p_emission_WE;

  // ports of submodule p_transition
  wire [31 : 0] p_transition_ADDR_1,
		p_transition_ADDR_2,
		p_transition_ADDR_3,
		p_transition_ADDR_4,
		p_transition_ADDR_5,
		p_transition_ADDR_IN,
		p_transition_D_IN,
		p_transition_D_OUT_1;
  wire p_transition_WE;

  // ports of submodule viterbi
  wire [31 : 0] viterbi_n_and_m_load_m,
		viterbi_n_and_m_load_n,
		viterbi_read_emission_idx,
		viterbi_read_outcome_idx,
		viterbi_read_transition_idx,
		viterbi_send_emission_data_data,
		viterbi_send_outcome_data_data,
		viterbi_send_transition_data_data;
  wire viterbi_EN_get_n_and_m_loaded,
       viterbi_EN_n_and_m_load,
       viterbi_EN_send_emission_data,
       viterbi_EN_send_outcome_data,
       viterbi_EN_send_transition_data,
       viterbi_EN_set_read_transition,
       viterbi_get_n_and_m_loaded,
       viterbi_get_read_emission,
       viterbi_get_read_outcome,
       viterbi_get_read_transition,
       viterbi_set_read_transition_val;

  // rule scheduling signals
  wire CAN_FIRE_RL_load_m_and_n,
       CAN_FIRE_RL_read_66,
       CAN_FIRE_RL_read_77,
       CAN_FIRE_RL_read_88,
       CAN_FIRE_RL_read_emission_matrix,
       CAN_FIRE_RL_read_outcome_matrix,
       CAN_FIRE_RL_read_transition_matrix,
       WILL_FIRE_RL_load_m_and_n,
       WILL_FIRE_RL_read_66,
       WILL_FIRE_RL_read_77,
       WILL_FIRE_RL_read_88,
       WILL_FIRE_RL_read_emission_matrix,
       WILL_FIRE_RL_read_outcome_matrix,
       WILL_FIRE_RL_read_transition_matrix;

  // submodule inputs
  RegFileLoad #(.file("./Inputs/input_small.dat"),
		.addr_width(32'd32),
		.data_width(32'd32),
		.lo(32'd0),
		.hi(32'd1023),
		.binary(1'd0)) inputs(.CLK(CLK),
				      .ADDR_1(inputs_ADDR_1),
				      .ADDR_2(inputs_ADDR_2),
				      .ADDR_3(inputs_ADDR_3),
				      .ADDR_4(inputs_ADDR_4),
				      .ADDR_5(inputs_ADDR_5),
				      .ADDR_IN(inputs_ADDR_IN),
				      .D_IN(inputs_D_IN),
				      .WE(inputs_WE),
				      .D_OUT_1(inputs_D_OUT_1),
				      .D_OUT_2(),
				      .D_OUT_3(),
				      .D_OUT_4(),
				      .D_OUT_5());

  // submodule n_and_m
  RegFileLoad #(.file("./Inputs/N_small.dat"),
		.addr_width(32'd32),
		.data_width(32'd32),
		.lo(32'd0),
		.hi(32'd1023),
		.binary(1'd0)) n_and_m(.CLK(CLK),
				       .ADDR_1(n_and_m_ADDR_1),
				       .ADDR_2(n_and_m_ADDR_2),
				       .ADDR_3(n_and_m_ADDR_3),
				       .ADDR_4(n_and_m_ADDR_4),
				       .ADDR_5(n_and_m_ADDR_5),
				       .ADDR_IN(n_and_m_ADDR_IN),
				       .D_IN(n_and_m_D_IN),
				       .WE(n_and_m_WE),
				       .D_OUT_1(n_and_m_D_OUT_1),
				       .D_OUT_2(n_and_m_D_OUT_2),
				       .D_OUT_3(),
				       .D_OUT_4(),
				       .D_OUT_5());

  // submodule p_emission
  RegFileLoad #(.file("./Inputs/B_small.dat"),
		.addr_width(32'd32),
		.data_width(32'd32),
		.lo(32'd0),
		.hi(32'd1023),
		.binary(1'd0)) p_emission(.CLK(CLK),
					  .ADDR_1(p_emission_ADDR_1),
					  .ADDR_2(p_emission_ADDR_2),
					  .ADDR_3(p_emission_ADDR_3),
					  .ADDR_4(p_emission_ADDR_4),
					  .ADDR_5(p_emission_ADDR_5),
					  .ADDR_IN(p_emission_ADDR_IN),
					  .D_IN(p_emission_D_IN),
					  .WE(p_emission_WE),
					  .D_OUT_1(p_emission_D_OUT_1),
					  .D_OUT_2(),
					  .D_OUT_3(),
					  .D_OUT_4(),
					  .D_OUT_5());

  // submodule p_transition
  RegFileLoad #(.file("./Inputs/A_small.dat"),
		.addr_width(32'd32),
		.data_width(32'd32),
		.lo(32'd0),
		.hi(32'd1023),
		.binary(1'd0)) p_transition(.CLK(CLK),
					    .ADDR_1(p_transition_ADDR_1),
					    .ADDR_2(p_transition_ADDR_2),
					    .ADDR_3(p_transition_ADDR_3),
					    .ADDR_4(p_transition_ADDR_4),
					    .ADDR_5(p_transition_ADDR_5),
					    .ADDR_IN(p_transition_ADDR_IN),
					    .D_IN(p_transition_D_IN),
					    .WE(p_transition_WE),
					    .D_OUT_1(p_transition_D_OUT_1),
					    .D_OUT_2(),
					    .D_OUT_3(),
					    .D_OUT_4(),
					    .D_OUT_5());

  // submodule viterbi
  mkViterbi viterbi(.CLK(CLK),
		    .RST_N(RST_N),
		    .n_and_m_load_m(viterbi_n_and_m_load_m),
		    .n_and_m_load_n(viterbi_n_and_m_load_n),
		    .send_emission_data_data(viterbi_send_emission_data_data),
		    .send_outcome_data_data(viterbi_send_outcome_data_data),
		    .send_transition_data_data(viterbi_send_transition_data_data),
		    .set_read_transition_val(viterbi_set_read_transition_val),
		    .EN_get_n_and_m_loaded(viterbi_EN_get_n_and_m_loaded),
		    .EN_n_and_m_load(viterbi_EN_n_and_m_load),
		    .EN_send_transition_data(viterbi_EN_send_transition_data),
		    .EN_send_emission_data(viterbi_EN_send_emission_data),
		    .EN_send_outcome_data(viterbi_EN_send_outcome_data),
		    .EN_set_read_transition(viterbi_EN_set_read_transition),
		    .get_n_and_m_loaded(viterbi_get_n_and_m_loaded),
		    .RDY_get_n_and_m_loaded(),
		    .RDY_n_and_m_load(),
		    .read_transition_idx(viterbi_read_transition_idx),
		    .RDY_read_transition_idx(),
		    .read_emission_idx(viterbi_read_emission_idx),
		    .RDY_read_emission_idx(),
		    .read_outcome_idx(viterbi_read_outcome_idx),
		    .RDY_read_outcome_idx(),
		    .RDY_send_transition_data(),
		    .RDY_send_emission_data(),
		    .RDY_send_outcome_data(),
		    .get_read_transition(viterbi_get_read_transition),
		    .RDY_get_read_transition(),
		    .RDY_set_read_transition(),
		    .get_read_emission(viterbi_get_read_emission),
		    .RDY_get_read_emission(),
		    .get_read_outcome(viterbi_get_read_outcome),
		    .RDY_get_read_outcome(),
		    .get_reset_decoder(),
		    .RDY_get_reset_decoder());

  // rule RL_read_66
  assign CAN_FIRE_RL_read_66 =
	     viterbi_get_read_transition && !read_transition_tb ;
  assign WILL_FIRE_RL_read_66 = CAN_FIRE_RL_read_66 ;

  // rule RL_read_77
  assign CAN_FIRE_RL_read_77 =
	     viterbi_get_read_emission && !read_emission_tb ;
  assign WILL_FIRE_RL_read_77 = CAN_FIRE_RL_read_77 ;

  // rule RL_read_88
  assign CAN_FIRE_RL_read_88 = viterbi_get_read_outcome && !read_outcome_tb ;
  assign WILL_FIRE_RL_read_88 = CAN_FIRE_RL_read_88 ;

  // rule RL_load_m_and_n
  assign CAN_FIRE_RL_load_m_and_n = 1'd1 ;
  assign WILL_FIRE_RL_load_m_and_n = 1'd1 ;

  // rule RL_read_transition_matrix
  assign CAN_FIRE_RL_read_transition_matrix = read_transition_tb ;
  assign WILL_FIRE_RL_read_transition_matrix = read_transition_tb ;

  // rule RL_read_emission_matrix
  assign CAN_FIRE_RL_read_emission_matrix = read_emission_tb ;
  assign WILL_FIRE_RL_read_emission_matrix = read_emission_tb ;

  // rule RL_read_outcome_matrix
  assign CAN_FIRE_RL_read_outcome_matrix = read_outcome_tb ;
  assign WILL_FIRE_RL_read_outcome_matrix = read_outcome_tb ;

  // register emission_idx_tb
  assign emission_idx_tb_D_IN = viterbi_read_emission_idx ;
  assign emission_idx_tb_EN = CAN_FIRE_RL_read_77 ;

  // register outcome_idx_tb
  assign outcome_idx_tb_D_IN = viterbi_read_outcome_idx ;
  assign outcome_idx_tb_EN = CAN_FIRE_RL_read_88 ;

  // register read_emission_tb
  assign read_emission_tb_D_IN = !read_emission_tb ;
  assign read_emission_tb_EN = read_emission_tb || WILL_FIRE_RL_read_77 ;

  // register read_outcome_tb
  assign read_outcome_tb_D_IN = !read_outcome_tb ;
  assign read_outcome_tb_EN = read_outcome_tb || WILL_FIRE_RL_read_88 ;

  // register read_transition_tb
  assign read_transition_tb_D_IN = !read_transition_tb ;
  assign read_transition_tb_EN = read_transition_tb || WILL_FIRE_RL_read_66 ;

  // register transition_idx_tb
  assign transition_idx_tb_D_IN = viterbi_read_transition_idx ;
  assign transition_idx_tb_EN = CAN_FIRE_RL_read_66 ;

  // submodule inputs
  assign inputs_ADDR_1 = outcome_idx_tb ;
  assign inputs_ADDR_2 = 32'h0 ;
  assign inputs_ADDR_3 = 32'h0 ;
  assign inputs_ADDR_4 = 32'h0 ;
  assign inputs_ADDR_5 = 32'h0 ;
  assign inputs_ADDR_IN = 32'h0 ;
  assign inputs_D_IN = 32'h0 ;
  assign inputs_WE = 1'b0 ;

  // submodule n_and_m
  assign n_and_m_ADDR_1 = 32'd1 ;
  assign n_and_m_ADDR_2 = 32'd0 ;
  assign n_and_m_ADDR_3 = 32'h0 ;
  assign n_and_m_ADDR_4 = 32'h0 ;
  assign n_and_m_ADDR_5 = 32'h0 ;
  assign n_and_m_ADDR_IN = 32'h0 ;
  assign n_and_m_D_IN = 32'h0 ;
  assign n_and_m_WE = 1'b0 ;

  // submodule p_emission
  assign p_emission_ADDR_1 = emission_idx_tb ;
  assign p_emission_ADDR_2 = 32'h0 ;
  assign p_emission_ADDR_3 = 32'h0 ;
  assign p_emission_ADDR_4 = 32'h0 ;
  assign p_emission_ADDR_5 = 32'h0 ;
  assign p_emission_ADDR_IN = 32'h0 ;
  assign p_emission_D_IN = 32'h0 ;
  assign p_emission_WE = 1'b0 ;

  // submodule p_transition
  assign p_transition_ADDR_1 = transition_idx_tb ;
  assign p_transition_ADDR_2 = 32'h0 ;
  assign p_transition_ADDR_3 = 32'h0 ;
  assign p_transition_ADDR_4 = 32'h0 ;
  assign p_transition_ADDR_5 = 32'h0 ;
  assign p_transition_ADDR_IN = 32'h0 ;
  assign p_transition_D_IN = 32'h0 ;
  assign p_transition_WE = 1'b0 ;

  // submodule viterbi
  assign viterbi_n_and_m_load_m = n_and_m_D_OUT_1 ;
  assign viterbi_n_and_m_load_n = n_and_m_D_OUT_2 ;
  assign viterbi_send_emission_data_data = p_emission_D_OUT_1 ;
  assign viterbi_send_outcome_data_data = inputs_D_OUT_1 ;
  assign viterbi_send_transition_data_data = p_transition_D_OUT_1 ;
  assign viterbi_set_read_transition_val = 1'b0 ;
  assign viterbi_EN_get_n_and_m_loaded = 1'd1 ;
  assign viterbi_EN_n_and_m_load = !viterbi_get_n_and_m_loaded ;
  assign viterbi_EN_send_transition_data = read_transition_tb ;
  assign viterbi_EN_send_emission_data = read_emission_tb ;
  assign viterbi_EN_send_outcome_data = read_outcome_tb ;
  assign viterbi_EN_set_read_transition = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        emission_idx_tb <= `BSV_ASSIGNMENT_DELAY 32'h0;
	outcome_idx_tb <= `BSV_ASSIGNMENT_DELAY 32'h0;
	read_emission_tb <= `BSV_ASSIGNMENT_DELAY 1'd0;
	read_outcome_tb <= `BSV_ASSIGNMENT_DELAY 1'd0;
	read_transition_tb <= `BSV_ASSIGNMENT_DELAY 1'd0;
	transition_idx_tb <= `BSV_ASSIGNMENT_DELAY 32'h0;
      end
    else
      begin
        if (emission_idx_tb_EN)
	  emission_idx_tb <= `BSV_ASSIGNMENT_DELAY emission_idx_tb_D_IN;
	if (outcome_idx_tb_EN)
	  outcome_idx_tb <= `BSV_ASSIGNMENT_DELAY outcome_idx_tb_D_IN;
	if (read_emission_tb_EN)
	  read_emission_tb <= `BSV_ASSIGNMENT_DELAY read_emission_tb_D_IN;
	if (read_outcome_tb_EN)
	  read_outcome_tb <= `BSV_ASSIGNMENT_DELAY read_outcome_tb_D_IN;
	if (read_transition_tb_EN)
	  read_transition_tb <= `BSV_ASSIGNMENT_DELAY read_transition_tb_D_IN;
	if (transition_idx_tb_EN)
	  transition_idx_tb <= `BSV_ASSIGNMENT_DELAY transition_idx_tb_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    emission_idx_tb = 32'hAAAAAAAA;
    outcome_idx_tb = 32'hAAAAAAAA;
    read_emission_tb = 1'h0;
    read_outcome_tb = 1'h0;
    read_transition_tb = 1'h0;
    transition_idx_tb = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkViterbiTestbench

